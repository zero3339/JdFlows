# JDFlows 从0开始开发完整指南

> **版本**: 1.1.0  
> **最后更新**: 2024-12-27  
> **作者**: JDFlows Team  
> **更新内容**: 新增UI/UX设计原则、紧凑布局、性能优化、完整组件库

---

## 📋 目录

1. [项目概述](#1-项目概述)
2. [技术栈详解](#2-技术栈详解)
3. [开发环境搭建](#3-开发环境搭建)
4. [项目架构深入解析](#4-项目架构深入解析)
5. [核心模块开发](#5-核心模块开发)
6. [GUI开发指南](#6-gui开发指南)
   - 6.1 GUI架构概览
   - 6.2 UI/UX设计原则 ⭐ 新增
   - 6.3 样式管理系统
   - 6.4 紧凑布局设计 ⭐ 新增
   - 6.5 完整组件库 ⭐ 新增
   - 6.6 页面开发
   - 6.7 组件通信
   - 6.8 UI性能优化 ⭐ 新增
   - 6.9 数据可视化 ⭐ 新增
7. [自动化引擎开发](#7-自动化引擎开发)
8. [数据管理开发](#8-数据管理开发)
9. [测试策略](#9-测试策略)
10. [部署和打包](#10-部署和打包)
11. [开发最佳实践](#11-开发最佳实践)
12. [国际化支持](#12-国际化支持) ⭐ 新增
13. [常见问题](#13-常见问题)

---

## 1. 项目概述

### 1.1 什么是 JDFlows？

JDFlows 是一个**现代化桌面应用程序**，专门用于京东商品采集和自动化操作。它采用**Python + PyQt6 + Playwright**技术栈，提供了：

- 🖥️ **原生桌面体验**：基于 PyQt6 的现代化界面
- 🤖 **智能自动化**：Playwright 驱动的浏览器自动化
- 🛡️ **反检测技术**：指纹管理、行为模拟、特征隐藏
- 📊 **数据管理**：SQLAlchemy ORM + SQLite 数据库
- ⚡ **异步处理**：asyncio + qasync 事件循环集成
- 🎨 **主题系统**：可定制的界面主题和样式

### 1.2 核心功能模块

```
JDFlows 功能架构
├── Dashboard（仪表盘）    - 系统状态监控、快捷操作
├── Browser（浏览器）      - 浏览器实例管理、性能监控
├── Collection（采集）     - 商品搜索、数据采集、价格监控
├── Purchase（购买）       - 任务队列、购买策略、订单生成
├── Order（订单）          - 订单管理、数据导出、批量处理
└── Settings（设置）       - 系统配置、主题设置、用户偏好
```

### 1.3 项目特色

- **模块化架构**：清晰的分层设计，易于维护和扩展
- **类型安全**：全面的类型注解和 mypy 类型检查
- **异步优先**：基于 asyncio 的异步编程模型
- **可测试性**：完善的单元测试和集成测试
- **性能优化**：缓存管理、虚拟滚动、延迟加载

---

## 2. 技术栈详解

### 2.1 核心依赖

| 技术 | 版本 | 用途 |
|------|------|------|
| **Python** | 3.11+ | 编程语言基础 |
| **PyQt6** | 6.6.0+ | GUI 框架 |
| **Playwright** | 1.40.0+ | 浏览器自动化引擎 |
| **SQLAlchemy** | 2.0.23+ | ORM 数据库管理 |
| **Pydantic** | 2.5.0+ | 数据验证和配置管理 |
| **qasync** | 0.25.0+ | Qt 和 asyncio 事件循环集成 |
| **loguru** | 0.7.2+ | 日志系统 |

### 2.2 开发工具

| 工具 | 用途 |
|------|------|
| **Poetry** | 依赖管理和打包工具 |
| **Black** | 代码格式化（88字符行长） |
| **Flake8** | 代码质量检查 |
| **mypy** | 静态类型检查 |
| **pytest** | 测试框架 |
| **pre-commit** | Git 钩子管理 |

### 2.3 反检测技术栈

```python
反检测技术层次
├── playwright-stealth      # Playwright 反检测插件
├── undetected-chromedriver # Chrome 反检测驱动
├── fake-useragent         # User-Agent 随机化
└── 自定义指纹管理          # Canvas、WebGL、Audio 指纹
```

---

## 3. 开发环境搭建

### 3.1 系统要求

- **操作系统**: Windows 10+, macOS 10.15+, Linux (Ubuntu 20.04+)
- **内存**: 至少 8GB RAM
- **硬盘**: 至少 2GB 可用空间
- **显示器**: 1920x1080 或更高分辨率

### 3.2 安装 Python 和 Poetry

#### Windows

```powershell
# 安装 Python 3.11
# 从 https://www.python.org/downloads/ 下载并安装

# 验证安装
python --version  # 应该显示 Python 3.11.x

# 安装 Poetry
(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -
```

#### macOS

```bash
# 使用 Homebrew 安装 Python
brew install python@3.11

# 安装 Poetry
curl -sSL https://install.python-poetry.org | python3 -
```

#### Linux

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install python3.11 python3.11-venv python3-pip

# 安装 Poetry
curl -sSL https://install.python-poetry.org | python3 -
```

### 3.3 克隆项目并安装依赖

```bash
# 克隆项目
git clone https://github.com/your-org/jdflows.git
cd jdflows

# 使用 Poetry 安装依赖（推荐）
poetry install

# 激活虚拟环境
poetry shell

# 或使用 pip
python -m venv .venv
source .venv/bin/activate  # Linux/Mac
# 或
.venv\Scripts\activate     # Windows

pip install -r requirements.txt
```

### 3.4 安装 Playwright 浏览器

```bash
# 安装 Chromium 浏览器（必需）
playwright install chromium

# 可选：安装所有浏览器
playwright install
```

### 3.5 配置开发工具

```bash
# 安装 pre-commit 钩子
pre-commit install

# 手动运行所有钩子（可选）
pre-commit run --all-files
```

### 3.6 验证环境

```bash
# 运行测试以验证环境
pytest tests/test_config.py -v

# 运行应用程序
python main.py
```

---

## 4. 项目架构深入解析

### 4.1 目录结构详解

```
jdflows/
├── src/                          # 源代码根目录
│   ├── core/                     # 核心模块
│   │   ├── application.py        # 应用程序核心和生命周期管理
│   │   ├── config.py             # 配置数据模型（Pydantic）
│   │   ├── config_manager.py     # 配置管理器（读取/写入/验证）
│   │   ├── logger.py             # 日志系统初始化
│   │   ├── logging_system.py     # 高级日志功能
│   │   ├── exceptions.py         # 自定义异常类
│   │   └── exception_handler.py  # 全局异常处理器
│   │
│   ├── gui/                      # GUI 界面模块
│   │   ├── main_window.py        # 主窗口（应用程序入口界面）
│   │   ├── style_manager.py      # 样式管理器（主题系统）
│   │   ├── shared_styles.qss     # 共享 QSS 样式表
│   │   │
│   │   ├── components/           # 可复用 UI 组件
│   │   │   ├── base_components.py         # 基础组件（按钮、标签等）
│   │   │   ├── navigation_components.py   # 导航组件（侧边栏等）
│   │   │   ├── notification_components.py # 通知组件
│   │   │   ├── dashboard.py              # 仪表盘组件
│   │   │   ├── browser_widgets.py        # 浏览器管理组件
│   │   │   ├── collection_widgets.py     # 采集相关组件
│   │   │   ├── purchase_widgets.py       # 购买相关组件
│   │   │   ├── order_widgets.py          # 订单管理组件
│   │   │   └── settings_widgets.py       # 设置页面组件
│   │   │
│   │   ├── pages/                # 页面组件
│   │   │   ├── dashboard_page.py         # 仪表盘页面
│   │   │   ├── browser_page.py           # 浏览器管理页面
│   │   │   ├── collection_page.py        # 采集页面
│   │   │   ├── purchase_page.py          # 购买页面
│   │   │   ├── order_page.py             # 订单管理页面
│   │   │   └── settings_page.py          # 设置页面
│   │   │
│   │   ├── controllers/          # 控制器（业务逻辑）
│   │   ├── layouts/              # 布局管理器
│   │   ├── themes/               # 主题资源
│   │   └── utils/                # GUI 工具函数
│   │
│   ├── automation/               # 自动化引擎模块
│   │   ├── browser_manager.py    # 浏览器实例管理
│   │   ├── stealth_config.py     # 反检测配置
│   │   ├── advanced_stealth.py   # 高级反检测技术
│   │   ├── fingerprint_manager.py # 指纹管理
│   │   ├── page_controller.py    # 页面控制器
│   │   ├── data_extractor.py     # 数据提取器
│   │   ├── jd_parser.py          # 京东页面解析器
│   │   ├── search_automation.py  # 搜索自动化
│   │   ├── product_extractor.py  # 商品信息提取
│   │   ├── price_monitor.py      # 价格监控
│   │   └── task_scheduler.py     # 任务调度器
│   │
│   ├── data/                     # 数据管理模块
│   │   ├── database.py           # 数据库连接管理
│   │   ├── models.py             # SQLAlchemy 数据模型
│   │   ├── repositories.py       # 数据仓库（CRUD 操作）
│   │   ├── cache.py              # 缓存管理
│   │   └── security.py           # 数据安全（加密/解密）
│   │
│   ├── utils/                    # 工具模块
│   │   ├── helpers.py            # 通用辅助函数
│   │   ├── validators.py         # 数据验证器
│   │   └── formatters.py         # 格式化工具
│   │
│   ├── optimization/             # 性能优化模块
│   │   ├── cache_manager.py      # 缓存策略管理
│   │   ├── memory_manager.py     # 内存管理
│   │   └── performance_profiler.py # 性能分析器
│   │
│   └── testing/                  # 测试工具模块
│       ├── fixtures.py           # 测试夹具
│       └── mocks.py              # Mock 对象
│
├── tests/                        # 测试代码
│   ├── conftest.py               # pytest 配置和全局夹具
│   ├── test_core/                # 核心模块测试
│   ├── test_gui/                 # GUI 模块测试
│   ├── test_automation/          # 自动化模块测试
│   └── test_integration/         # 集成测试
│
├── config/                       # 配置文件
│   ├── app.json                  # 应用配置
│   ├── system.json               # 系统配置
│   ├── user.json                 # 用户配置
│   └── runtime.json              # 运行时配置
│
├── resources/                    # 资源文件
│   ├── icons/                    # 图标资源
│   ├── images/                   # 图片资源
│   └── fonts/                    # 字体资源
│
├── docs/                         # 项目文档
│   ├── api/                      # API 文档
│   ├── guides/                   # 开发指南
│   └── architecture/             # 架构文档
│
├── scripts/                      # 开发脚本
│   ├── compile_ui.py             # UI 文件编译
│   ├── start_designer.py         # 启动 Qt Designer
│   └── dev_tools.py              # 开发工具集
│
├── main.py                       # 应用程序入口
├── pyproject.toml                # Poetry 配置
├── requirements.txt              # pip 依赖列表
├── pytest.ini                    # pytest 配置
├── mypy.ini                      # mypy 配置
├── .flake8                       # flake8 配置
├── .gitignore                    # Git 忽略文件
└── README.md                     # 项目说明
```

### 4.2 架构分层

```
┌─────────────────────────────────────────────────────────┐
│                   展示层 (Presentation)                  │
│  ┌─────────────────────────────────────────────────┐   │
│  │  GUI (PyQt6)                                    │   │
│  │  - MainWindow                                   │   │
│  │  - Pages (Dashboard, Browser, Collection, ...) │   │
│  │  - Components (Widgets, Dialogs)               │   │
│  └─────────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────┐
│                 业务逻辑层 (Business Logic)              │
│  ┌─────────────────────────────────────────────────┐   │
│  │  Controllers                                    │   │
│  │  - BrowserController                            │   │
│  │  - CollectionController                         │   │
│  │  - PurchaseController                           │   │
│  └─────────────────────────────────────────────────┘   │
└───────────────────────┬─────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────┐
│                  服务层 (Services)                       │
│  ┌─────────────────┐  ┌─────────────────┐              │
│  │  Automation     │  │  Data           │              │
│  │  - BrowserMgr   │  │  - Database     │              │
│  │  - Stealth      │  │  - Repositories │              │
│  │  - Extractor    │  │  - Cache        │              │
│  └─────────────────┘  └─────────────────┘              │
└───────────────────────┬─────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────┐
│                  基础设施层 (Infrastructure)             │
│  ┌─────────────────────────────────────────────────┐   │
│  │  Core                                           │   │
│  │  - Application Core                             │   │
│  │  - Config Manager                               │   │
│  │  - Logger                                       │   │
│  │  - Exception Handler                            │   │
│  └─────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 4.3 核心设计模式

#### 4.3.1 单例模式（Singleton）

用于全局唯一的管理器对象：

```python
# 样式管理器单例
_style_manager_instance = None

def get_style_manager() -> StyleManager:
    global _style_manager_instance
    if _style_manager_instance is None:
        _style_manager_instance = StyleManager()
    return _style_manager_instance
```

#### 4.3.2 工厂模式（Factory）

用于创建组件和对象：

```python
# 按钮工厂
def create_primary_button(text: str, parent=None) -> StyledButton:
    button = StyledButton(text, ComponentStyle.BUTTON_PRIMARY, parent)
    return button
```

#### 4.3.3 观察者模式（Observer）

使用 Qt 信号槽机制实现：

```python
class MainWindow(QMainWindow):
    theme_changed = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.theme_changed.connect(self.on_theme_changed)
```

#### 4.3.4 策略模式（Strategy）

用于不同的反检测策略：

```python
class StealthStrategy(ABC):
    @abstractmethod
    async def apply(self, page: Page) -> None:
        pass

class CanvasFingerprintStrategy(StealthStrategy):
    async def apply(self, page: Page) -> None:
        # 实现 Canvas 指纹随机化
        pass
```

---

## 5. 核心模块开发

### 5.1 应用程序核心（src/core/application.py）

应用程序核心负责整个应用的生命周期管理。

#### 5.1.1 ApplicationCore 类

```python
"""
应用程序核心类

职责:
- 初始化所有核心组件
- 管理应用程序生命周期
- 协调各模块之间的交互
"""

class ApplicationCore(QObject):
    # 信号定义
    startup_completed = pyqtSignal()
    shutdown_started = pyqtSignal()
    error_occurred = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.settings: Optional[Settings] = None
        self.config_manager = None
        self.logger = None
        self.main_window: Optional[ModernMainWindow] = None
        self._initialized = False
        self._shutdown_requested = False
    
    async def initialize(self) -> None:
        """初始化应用程序核心组件"""
        try:
            # 1. 初始化配置管理器
            self.config_manager = get_config_manager()
            
            # 2. 加载配置
            self.settings = Settings()
            
            # 3. 设置日志系统
            setup_logger(self.settings)
            self.logger = get_logger("ApplicationCore")
            
            # 4. 创建主窗口
            self.main_window = ModernMainWindow(self.settings)
            self.main_window.window_closed.connect(self.request_shutdown)
            
            self._initialized = True
            self.startup_completed.emit()
            
        except Exception as e:
            error_msg = f"应用程序初始化失败: {e}"
            if self.logger:
                self.logger.error(error_msg)
            self.error_occurred.emit(error_msg)
            raise JDFlowsError(error_msg)
```

#### 5.1.2 JDFlowsApplication 类

```python
"""
应用程序主类

职责:
- 创建 Qt 应用程序
- 设置 qasync 事件循环
- 运行应用程序
"""

class JDFlowsApplication:
    def __init__(self):
        self.qt_app: Optional[QApplication] = None
        self.event_loop: Optional[asyncio.AbstractEventLoop] = None
        self.core: Optional[ApplicationCore] = None
    
    def run(self) -> int:
        """运行应用程序"""
        try:
            # 创建 Qt 应用程序
            self.qt_app = QApplication(sys.argv)
            
            # 设置 qasync 事件循环
            self.event_loop = qasync.QEventLoop(self.qt_app)
            asyncio.set_event_loop(self.event_loop)
            
            # 运行异步主函数
            return self.event_loop.run_until_complete(self.run_async())
            
        except KeyboardInterrupt:
            return 0
        except Exception as e:
            print(f"应用程序启动失败: {e}")
            return 1
```

### 5.2 配置管理（src/core/config.py & config_manager.py）

#### 5.2.1 配置数据模型（Pydantic）

```python
"""
配置数据模型

使用 Pydantic 进行数据验证和类型安全
"""

from pydantic import BaseModel, Field

class AppConfig(BaseModel):
    """应用配置"""
    name: str = Field(default="JDFlows")
    version: str = Field(default="0.1.0")
    debug: bool = Field(default=False)

class DatabaseConfig(BaseModel):
    """数据库配置"""
    url: str = Field(default="sqlite:///data/jdflows.db")
    echo: bool = Field(default=False)
    pool_size: int = Field(default=5, ge=1, le=20)

class BrowserConfig(BaseModel):
    """浏览器配置"""
    headless: bool = Field(default=False)
    timeout: int = Field(default=30000, ge=1000)
    user_data_dir: str = Field(default="data/browser")

class Settings(BaseModel):
    """主配置类"""
    app: AppConfig = Field(default_factory=AppConfig)
    database: DatabaseConfig = Field(default_factory=DatabaseConfig)
    browser: BrowserConfig = Field(default_factory=BrowserConfig)
```

#### 5.2.2 配置管理器

```python
"""
配置管理器

职责:
- 读取/写入配置文件
- 合并多层配置
- 验证配置有效性
"""

class ConfigManager:
    def __init__(self, config_dir: Path = Path("config")):
        self.config_dir = config_dir
        self.config_files = {
            "app": config_dir / "app.json",
            "system": config_dir / "system.json",
            "user": config_dir / "user.json",
            "runtime": config_dir / "runtime.json",
        }
    
    def load_config(self) -> Settings:
        """加载所有配置文件并合并"""
        merged = {}
        
        for name, file_path in self.config_files.items():
            if file_path.exists():
                with open(file_path, "r", encoding="utf-8") as f:
                    config = json.load(f)
                    merged.update(config)
        
        return Settings(**merged)
    
    def save_config(self, settings: Settings) -> None:
        """保存配置"""
        # 实现配置保存逻辑
        pass
```

### 5.3 日志系统（src/core/logger.py）

```python
"""
日志系统

使用 loguru 实现强大的日志功能
"""

from loguru import logger
import sys

def setup_logger(settings: Settings) -> None:
    """设置日志系统"""
    # 移除默认处理器
    logger.remove()
    
    # 控制台输出
    logger.add(
        sys.stderr,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | "
               "<level>{level: <8}</level> | "
               "<cyan>{name}</cyan>:<cyan>{function}</cyan> - "
               "<level>{message}</level>",
        level="DEBUG" if settings.app.debug else "INFO",
    )
    
    # 文件输出
    logger.add(
        "logs/jdflows_{time}.log",
        rotation="100 MB",
        retention="30 days",
        compression="zip",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {name}:{function} - {message}",
        level="DEBUG",
    )

def get_logger(name: str):
    """获取 logger 实例"""
    return logger.bind(name=name)
```

---

## 6. GUI开发指南

### 6.1 GUI 架构概览

JDFlows 的 GUI 采用**组件化**和**页面化**的设计：

```
GUI 架构
├── MainWindow（主窗口）
│   ├── NavigationSidebar（导航侧边栏）
│   ├── ContentArea（内容区域 - QStackedWidget）
│   │   ├── DashboardPage
│   │   ├── BrowserPage
│   │   ├── CollectionPage
│   │   ├── PurchasePage
│   │   ├── OrderPage
│   │   └── SettingsPage
│   └── StatusBar（状态栏）
│
└── StyleManager（样式管理器）
    ├── 主题系统（Light/Dark/Neutral/Terminal）
    └── 组件样式（ComponentStyle枚举）
```

### 6.2 UI/UX 设计原则

#### 6.2.1 响应式设计

```python
"""
响应式布局管理

根据窗口大小自动调整布局
"""

class ResponsiveWidget(StyledWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.breakpoints = {
            "xs": 480,   # 超小屏幕
            "sm": 768,   # 小屏幕
            "md": 1024,  # 中等屏幕
            "lg": 1440,  # 大屏幕
            "xl": 1920   # 超大屏幕
        }
        self.current_breakpoint = "lg"
    
    def resizeEvent(self, event):
        """窗口大小改变时触发"""
        super().resizeEvent(event)
        width = event.size().width()
        
        # 确定当前断点
        if width < self.breakpoints["xs"]:
            self.current_breakpoint = "xs"
        elif width < self.breakpoints["sm"]:
            self.current_breakpoint = "sm"
        elif width < self.breakpoints["md"]:
            self.current_breakpoint = "md"
        elif width < self.breakpoints["lg"]:
            self.current_breakpoint = "lg"
        else:
            self.current_breakpoint = "xl"
        
        # 应用响应式布局
        self.apply_responsive_layout()
    
    def apply_responsive_layout(self):
        """根据断点应用不同布局"""
        if self.current_breakpoint in ["xs", "sm"]:
            # 移动端布局：单列
            self.set_mobile_layout()
        else:
            # 桌面端布局：多列
            self.set_desktop_layout()
```

#### 6.2.2 高 DPI 支持

```python
"""
高 DPI 屏幕支持

确保在不同分辨率下显示清晰
"""

# main.py
import sys
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import Qt

def setup_high_dpi():
    """设置高 DPI 支持"""
    # 启用高 DPI 缩放
    QApplication.setHighDpiScaleFactorRoundingPolicy(
        Qt.HighDpiScaleFactorRoundingPolicy.PassThrough
    )
    
    # 启用高 DPI pixmaps
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_UseHighDpiPixmaps)
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_EnableHighDpiScaling)

# 在创建 QApplication 之前调用
setup_high_dpi()
app = QApplication(sys.argv)

# 获取屏幕 DPI 比例
screen = app.primaryScreen()
dpi_ratio = screen.devicePixelRatio()
print(f"DPI 比例: {dpi_ratio}")

# 根据 DPI 调整字体和图标大小
base_font_size = 14
scaled_font_size = int(base_font_size * dpi_ratio)
```

#### 6.2.3 无障碍访问（Accessibility）

```python
"""
无障碍访问支持

确保应用可被所有用户使用
"""

class AccessibleButton(QPushButton):
    def __init__(self, text: str, accessible_name: str = None,
                 accessible_description: str = None, parent=None):
        super().__init__(text, parent)
        
        # 设置无障碍属性
        self.setAccessibleName(accessible_name or text)
        if accessible_description:
            self.setAccessibleDescription(accessible_description)
        
        # 确保可通过键盘访问
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)
    
    def keyPressEvent(self, event):
        """键盘事件处理"""
        # 支持空格键和回车键触发
        if event.key() in [Qt.Key.Key_Space, Qt.Key.Key_Return, Qt.Key.Key_Enter]:
            self.click()
        else:
            super().keyPressEvent(event)

# 使用示例
button = AccessibleButton(
    "启动采集",
    accessible_name="启动商品采集按钮",
    accessible_description="点击此按钮开始采集京东商品信息"
)

# 设置快捷键
button.setShortcut(QKeySequence("Ctrl+S"))
button.setToolTip("启动采集 (Ctrl+S)")
```

#### 6.2.4 颜色对比度和 WCAG 合规

```python
"""
颜色对比度检查

确保符合 WCAG 2.1 AA 标准
"""

from typing import Tuple

class ColorContrast:
    @staticmethod
    def relative_luminance(rgb: Tuple[int, int, int]) -> float:
        """计算相对亮度"""
        def linearize(channel: int) -> float:
            c = channel / 255.0
            if c <= 0.03928:
                return c / 12.92
            return ((c + 0.055) / 1.055) ** 2.4
        
        r, g, b = rgb
        return 0.2126 * linearize(r) + 0.7152 * linearize(g) + 0.0722 * linearize(b)
    
    @staticmethod
    def contrast_ratio(color1: Tuple[int, int, int], 
                      color2: Tuple[int, int, int]) -> float:
        """计算对比度"""
        l1 = ColorContrast.relative_luminance(color1)
        l2 = ColorContrast.relative_luminance(color2)
        
        lighter = max(l1, l2)
        darker = min(l1, l2)
        
        return (lighter + 0.05) / (darker + 0.05)
    
    @staticmethod
    def meets_wcag_aa(color1: Tuple[int, int, int], 
                     color2: Tuple[int, int, int],
                     is_large_text: bool = False) -> bool:
        """检查是否符合 WCAG AA 标准"""
        ratio = ColorContrast.contrast_ratio(color1, color2)
        
        # 大文本需要 3:1，普通文本需要 4.5:1
        threshold = 3.0 if is_large_text else 4.5
        return ratio >= threshold

# 使用示例
bg_color = (30, 30, 30)    # 深灰背景
text_color = (255, 255, 255)  # 白色文本

if ColorContrast.meets_wcag_aa(bg_color, text_color):
    print("✓ 颜色对比度符合 WCAG AA 标准")
else:
    print("✗ 颜色对比度不符合标准，请调整配色")
```

### 6.3 样式管理系统

#### 6.3.1 StyleManager 类

```python
"""
样式管理器

职责:
- 管理应用主题
- 应用组件样式
- 动态切换主题
"""

class StyleManager(QObject):
    theme_changed = pyqtSignal(str)
    
    def __init__(self):
        super().__init__()
        self.current_theme = ThemeType.DARK
        self.themes = self._load_themes()
        self.component_styles = self._load_component_styles()
    
    def set_theme(self, widget: QWidget, theme: str) -> None:
        """应用主题到组件"""
        if theme in self.themes:
            stylesheet = self.themes[theme]
            widget.setStyleSheet(stylesheet)
            self.current_theme = theme
            self.theme_changed.emit(theme)
    
    def apply_component_style(self, widget: QWidget, style_class: str) -> None:
        """应用组件样式类"""
        current = widget.property("styleClass") or []
        if style_class not in current:
            current.append(style_class)
            widget.setProperty("styleClass", current)
            widget.style().unpolish(widget)
            widget.style().polish(widget)
```

#### 6.2.2 QSS 样式表

```qss
/* shared_styles.qss */

/* ========== 主题变量 ========== */
/* Dark Theme */
.dark {
    qproperty-backgroundColor: #1e1e1e;
    qproperty-foregroundColor: #ffffff;
    qproperty-accentColor: #0078d4;
}

/* ========== 基础组件 ========== */
QWidget {
    background-color: #1e1e1e;
    color: #ffffff;
    font-family: "Segoe UI", "Microsoft YaHei UI", sans-serif;
    font-size: 14px;
}

/* ========== 按钮样式 ========== */
QPushButton.btn-primary {
    background-color: #0078d4;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 8px 16px;
    font-weight: 600;
}

QPushButton.btn-primary:hover {
    background-color: #106ebe;
}

QPushButton.btn-primary:pressed {
    background-color: #005a9e;
}
```

### 6.3 基础组件开发

#### 6.3.1 StyledWidget 基类

```python
"""
基础样式化组件

所有自定义组件继承此类
"""

class StyledWidget(QWidget):
    value_changed = pyqtSignal(object)
    action_triggered = pyqtSignal(str)
    theme_changed = pyqtSignal(str)
    
    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.logger = get_logger(self.__class__.__name__)
        self.style_manager = get_style_manager()
        self._current_theme = ThemeType.DARK
        
        # 应用默认主题
        self.apply_theme(self._current_theme)
        
        # 监听主题变化
        self.style_manager.theme_changed.connect(self.on_theme_changed)
    
    def apply_theme(self, theme: str) -> None:
        """应用主题"""
        self.style_manager.set_theme(self, theme)
        self._current_theme = theme
    
    def apply_component_style(self, style_class: str) -> None:
        """应用组件样式类"""
        self.style_manager.apply_component_style(self, style_class)
```

#### 6.3.2 StyledButton 组件

```python
"""
样式化按钮组件
"""

class StyledButton(QPushButton):
    def __init__(self, text: str, style_class: str = ComponentStyle.BUTTON_DEFAULT,
                 parent: Optional[QWidget] = None):
        super().__init__(text, parent)
        self.style_manager = get_style_manager()
        
        # 应用样式类
        self.apply_component_style(style_class)
        
        # 设置光标
        self.setCursor(Qt.CursorShape.PointingHandCursor)
    
    def apply_component_style(self, style_class: str) -> None:
        """应用样式类"""
        self.style_manager.apply_component_style(self, style_class)
```

### 6.4 页面开发

#### 6.4.1 页面基类

```python
"""
页面基类

所有页面继承此类
"""

class BasePage(StyledWidget):
    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.logger = get_logger(self.__class__.__name__)
        self.init_ui()
    
    def init_ui(self) -> None:
        """初始化UI - 子类实现"""
        raise NotImplementedError
    
    def on_activated(self) -> None:
        """页面激活时调用 - 子类可选实现"""
        pass
    
    def on_deactivated(self) -> None:
        """页面失活时调用 - 子类可选实现"""
        pass
```

#### 6.4.2 Dashboard 页面示例

```python
"""
仪表盘页面

显示系统状态、关键指标和快捷操作
"""

class DashboardPage(BasePage):
    def init_ui(self) -> None:
        """初始化UI"""
        # 主布局
        layout = QVBoxLayout(self)
        layout.setSpacing(16)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # 标题
        title = create_title_label("系统仪表盘")
        layout.addWidget(title)
        
        # 指标卡片区域
        metrics_layout = QGridLayout()
        metrics_layout.setSpacing(16)
        
        # 创建指标卡片
        self.cpu_card = MetricCard("CPU使用率", "0%", trend="正常")
        self.memory_card = MetricCard("内存使用", "0 MB", trend="正常")
        self.tasks_card = MetricCard("运行任务", "0", trend="无")
        self.status_card = MetricCard("系统状态", "就绪", trend="正常")
        
        metrics_layout.addWidget(self.cpu_card, 0, 0)
        metrics_layout.addWidget(self.memory_card, 0, 1)
        metrics_layout.addWidget(self.tasks_card, 1, 0)
        metrics_layout.addWidget(self.status_card, 1, 1)
        
        layout.addLayout(metrics_layout)
        
        # 快捷操作区域
        actions_group = self.create_actions_section()
        layout.addWidget(actions_group)
        
        # 弹性空间
        layout.addStretch()
    
    def create_actions_section(self) -> QWidget:
        """创建快捷操作区域"""
        group = QGroupBox("快捷操作")
        layout = QHBoxLayout(group)
        
        start_btn = create_primary_button("启动采集")
        start_btn.clicked.connect(self.on_start_collection)
        
        stop_btn = StyledButton("停止任务", ComponentStyle.BUTTON_DANGER)
        stop_btn.clicked.connect(self.on_stop_tasks)
        
        layout.addWidget(start_btn)
        layout.addWidget(stop_btn)
        layout.addStretch()
        
        return group
    
    def on_start_collection(self):
        """启动采集"""
        self.logger.info("启动采集任务")
        # 实现采集逻辑
```

### 6.5 组件通信

#### 6.5.1 信号槽机制

```python
# 定义信号
class CollectionPage(BasePage):
    collection_started = pyqtSignal(dict)  # 采集开始信号
    collection_completed = pyqtSignal(dict)  # 采集完成信号
    
    def start_collection(self, keyword: str):
        # 发射信号
        self.collection_started.emit({"keyword": keyword})
        
        # 执行采集逻辑
        # ...
        
        # 完成后发射信号
        self.collection_completed.emit({"count": 100})

# 连接信号
page = CollectionPage()
page.collection_started.connect(lambda data: print(f"开始采集: {data}"))
page.collection_completed.connect(lambda data: print(f"采集完成: {data}"))
```

#### 6.5.2 事件总线

```python
"""
事件总线 - 全局事件通信

用于跨组件的松耦合通信
"""

class EventBus(QObject):
    _instance = None
    event_emitted = pyqtSignal(str, object)
    
    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance
    
    def emit_event(self, event_type: str, data: Any = None):
        """发射事件"""
        self.event_emitted.emit(event_type, data)
    
    def subscribe(self, event_type: str, handler: callable):
        """订阅事件"""
        self.event_emitted.connect(
            lambda etype, data: handler(data) if etype == event_type else None
        )

# 使用示例
bus = EventBus.get_instance()

# 订阅事件
bus.subscribe("collection_completed", lambda data: print(f"采集完成: {data}"))

# 发射事件
bus.emit_event("collection_completed", {"count": 100})
```

---

## 7. 自动化引擎开发

### 7.1 浏览器管理器

#### 7.1.1 BrowserManager 类

```python
"""
浏览器管理器

职责:
- 创建和管理 Playwright 浏览器实例
- 配置反检测技术
- 监控浏览器性能
"""

class BrowserManager:
    def __init__(self, settings: Settings):
        self.settings = settings
        self.logger = get_logger("BrowserManager")
        self.instances: Dict[str, BrowserInstance] = {}
        self._playwright = None
        self._browser_type = None
    
    async def initialize(self) -> None:
        """初始化 Playwright"""
        from playwright.async_api import async_playwright
        
        self._playwright = await async_playwright().start()
        self._browser_type = self._playwright.chromium
        self.logger.info("Playwright 初始化成功")
    
    async def create_instance(self, instance_id: str,
                             use_stealth: bool = True) -> BrowserInstance:
        """创建浏览器实例"""
        try:
            # 创建浏览器
            browser = await self._browser_type.launch(
                headless=self.settings.browser.headless,
                args=[
                    "--disable-blink-features=AutomationControlled",
                    "--no-sandbox",
                ]
            )
            
            # 创建上下文
            context = await browser.new_context(
                viewport={"width": 1920, "height": 1080},
                user_agent=self._generate_user_agent(),
            )
            
            # 创建页面
            page = await context.new_page()
            
            # 应用反检测
            if use_stealth:
                await self._apply_stealth(page)
            
            # 创建实例对象
            instance = BrowserInstance(
                instance_id=instance_id,
                status=BrowserStatus.RUNNING,
                browser=browser,
                context=context,
                page=page,
                created_at=time.time(),
            )
            
            self.instances[instance_id] = instance
            self.logger.info(f"浏览器实例 {instance_id} 创建成功")
            
            return instance
            
        except Exception as e:
            self.logger.error(f"创建浏览器实例失败: {e}")
            raise BrowserError(f"创建浏览器实例失败: {e}")
```

### 7.2 反检测技术

#### 7.2.1 基础反检测配置

```python
"""
反检测配置

实现各种反检测技术
"""

class AntiDetectionConfig:
    @staticmethod
    async def hide_webdriver(page: Page) -> None:
        """隐藏 WebDriver 特征"""
        await page.add_init_script("""
            Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined
            });
        """)
    
    @staticmethod
    async def spoof_permissions(page: Page) -> None:
        """伪装权限"""
        await page.add_init_script("""
            const originalQuery = window.navigator.permissions.query;
            window.navigator.permissions.query = (parameters) => (
                parameters.name === 'notifications' ?
                    Promise.resolve({ state: Notification.permission }) :
                    originalQuery(parameters)
            );
        """)
    
    @staticmethod
    async def randomize_canvas_fingerprint(page: Page) -> None:
        """Canvas 指纹随机化"""
        await page.add_init_script("""
            const getContext = HTMLCanvasElement.prototype.getContext;
            HTMLCanvasElement.prototype.getContext = function(...args) {
                const context = getContext.apply(this, args);
                if (args[0] === '2d') {
                    const getImageData = context.getImageData;
                    context.getImageData = function(...args) {
                        const imageData = getImageData.apply(this, args);
                        // 添加微小噪声
                        for (let i = 0; i < imageData.data.length; i += 4) {
                            imageData.data[i] += Math.random() * 0.01;
                        }
                        return imageData;
                    };
                }
                return context;
            };
        """)
```

#### 7.2.2 高级反检测策略

```python
"""
高级反检测策略

实现更复杂的反检测技术
"""

class AdvancedStealth:
    def __init__(self):
        self.logger = get_logger("AdvancedStealth")
    
    async def apply_all(self, page: Page) -> None:
        """应用所有反检测技术"""
        await self.hide_automation_features(page)
        await self.randomize_fingerprints(page)
        await self.simulate_human_behavior(page)
    
    async def simulate_human_behavior(self, page: Page) -> None:
        """模拟人类行为"""
        # 随机鼠标移动
        await page.mouse.move(
            random.randint(100, 800),
            random.randint(100, 600),
            steps=random.randint(5, 15)
        )
        
        # 随机延迟
        await asyncio.sleep(random.uniform(0.1, 0.5))
```

### 7.3 数据提取器

```python
"""
数据提取器

从页面中提取商品信息
"""

class ProductExtractor:
    def __init__(self, browser_manager: BrowserManager):
        self.browser_manager = browser_manager
        self.logger = get_logger("ProductExtractor")
    
    async def extract_product_info(self, page: Page, url: str) -> Dict[str, Any]:
        """提取商品信息"""
        try:
            # 导航到商品页面
            await page.goto(url, wait_until="networkidle")
            
            # 提取商品信息
            product_info = await page.evaluate("""() => {
                return {
                    title: document.querySelector('.sku-name')?.textContent.trim(),
                    price: document.querySelector('.price')?.textContent.trim(),
                    stock: document.querySelector('.stock')?.textContent.trim(),
                    images: Array.from(document.querySelectorAll('.img-item img'))
                               .map(img => img.src),
                };
            }""")
            
            self.logger.info(f"成功提取商品信息: {product_info['title']}")
            return product_info
            
        except Exception as e:
            self.logger.error(f"提取商品信息失败: {e}")
            raise
```

---

## 8. 数据管理开发

### 8.1 数据模型（SQLAlchemy）

```python
"""
数据模型

定义数据库表结构
"""

from sqlalchemy import Column, Integer, String, Float, DateTime, Text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class Product(Base):
    """商品模型"""
    __tablename__ = "products"
    
    id = Column(Integer, primary_key=True)
    sku_id = Column(String(50), unique=True, nullable=False, index=True)
    title = Column(String(500), nullable=False)
    price = Column(Float, nullable=False)
    original_price = Column(Float)
    stock_status = Column(String(50))
    shop_name = Column(String(200))
    category = Column(String(100))
    images = Column(Text)  # JSON 格式存储
    description = Column(Text)
    url = Column(String(500))
    created_at = Column(DateTime, default=datetime.now)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<Product(sku_id='{self.sku_id}', title='{self.title}')>"

class Order(Base):
    """订单模型"""
    __tablename__ = "orders"
    
    id = Column(Integer, primary_key=True)
    order_id = Column(String(50), unique=True, nullable=False)
    product_sku = Column(String(50), nullable=False)
    quantity = Column(Integer, default=1)
    total_price = Column(Float, nullable=False)
    status = Column(String(20), default="pending")  # pending, completed, failed
    created_at = Column(DateTime, default=datetime.now)
    completed_at = Column(DateTime)
    
    def __repr__(self):
        return f"<Order(order_id='{self.order_id}', status='{self.status}')>"
```

### 8.2 数据库管理

```python
"""
数据库管理器

管理数据库连接和会话
"""

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from contextlib import contextmanager

class DatabaseManager:
    def __init__(self, database_url: str):
        self.engine = create_engine(
            database_url,
            echo=False,
            pool_size=5,
            max_overflow=10,
        )
        self.SessionLocal = sessionmaker(
            autocommit=False,
            autoflush=False,
            bind=self.engine
        )
        self.logger = get_logger("DatabaseManager")
    
    def create_tables(self) -> None:
        """创建所有表"""
        Base.metadata.create_all(bind=self.engine)
        self.logger.info("数据库表创建成功")
    
    @contextmanager
    def get_session(self) -> Session:
        """获取数据库会话（上下文管理器）"""
        session = self.SessionLocal()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()
```

### 8.3 数据仓库（Repository Pattern）

```python
"""
商品数据仓库

实现 CRUD 操作
"""

class ProductRepository:
    def __init__(self, db_manager: DatabaseManager):
        self.db_manager = db_manager
        self.logger = get_logger("ProductRepository")
    
    def create(self, product_data: Dict[str, Any]) -> Product:
        """创建商品"""
        with self.db_manager.get_session() as session:
            product = Product(**product_data)
            session.add(product)
            session.flush()
            self.logger.info(f"创建商品: {product.sku_id}")
            return product
    
    def get_by_sku(self, sku_id: str) -> Optional[Product]:
        """根据 SKU 获取商品"""
        with self.db_manager.get_session() as session:
            return session.query(Product).filter(Product.sku_id == sku_id).first()
    
    def update(self, sku_id: str, update_data: Dict[str, Any]) -> Optional[Product]:
        """更新商品"""
        with self.db_manager.get_session() as session:
            product = session.query(Product).filter(Product.sku_id == sku_id).first()
            if product:
                for key, value in update_data.items():
                    setattr(product, key, value)
                self.logger.info(f"更新商品: {sku_id}")
            return product
    
    def delete(self, sku_id: str) -> bool:
        """删除商品"""
        with self.db_manager.get_session() as session:
            product = session.query(Product).filter(Product.sku_id == sku_id).first()
            if product:
                session.delete(product)
                self.logger.info(f"删除商品: {sku_id}")
                return True
            return False
    
    def search(self, keyword: str, limit: int = 100) -> List[Product]:
        """搜索商品"""
        with self.db_manager.get_session() as session:
            return (
                session.query(Product)
                .filter(Product.title.like(f"%{keyword}%"))
                .limit(limit)
                .all()
            )
```

---

## 9. 测试策略

### 9.1 测试架构

```
测试层次
├── 单元测试 (Unit Tests)
│   ├── 测试单个函数和方法
│   └── Mock 外部依赖
│
├── 集成测试 (Integration Tests)
│   ├── 测试模块之间的交互
│   └── 使用真实或测试数据库
│
├── GUI 测试 (GUI Tests)
│   ├── 使用 pytest-qt
│   └── 测试用户交互
│
└── 端到端测试 (E2E Tests)
    ├── 测试完整业务流程
    └── 模拟真实用户场景
```

### 9.2 单元测试示例

```python
"""
配置管理器单元测试
"""

import pytest
from src.core.config_manager import ConfigManager
from src.core.config import Settings

class TestConfigManager:
    @pytest.fixture
    def config_manager(self, tmp_path):
        """创建临时配置管理器"""
        return ConfigManager(config_dir=tmp_path)
    
    def test_load_config_empty(self, config_manager):
        """测试加载空配置"""
        settings = config_manager.load_config()
        assert isinstance(settings, Settings)
        assert settings.app.name == "JDFlows"
    
    def test_save_and_load_config(self, config_manager):
        """测试保存和加载配置"""
        settings = Settings(app={"name": "Test App"})
        config_manager.save_config(settings)
        
        loaded = config_manager.load_config()
        assert loaded.app.name == "Test App"
```

### 9.3 GUI 测试示例

```python
"""
Dashboard 页面 GUI 测试
"""

import pytest
from PyQt6.QtCore import Qt
from src.gui.pages.dashboard_page import DashboardPage

class TestDashboardPage:
    @pytest.fixture
    def page(self, qtbot):
        """创建 Dashboard 页面"""
        page = DashboardPage()
        qtbot.addWidget(page)
        return page
    
    def test_page_creation(self, page):
        """测试页面创建"""
        assert page is not None
        assert page.isVisible()
    
    def test_metric_cards(self, page, qtbot):
        """测试指标卡片"""
        assert page.cpu_card is not None
        assert page.memory_card is not None
        
        # 更新指标
        page.cpu_card.update_value("50%", "正常")
        assert "50%" in page.cpu_card.value_label.text()
    
    def test_action_buttons(self, page, qtbot):
        """测试操作按钮"""
        start_btn = page.findChild(QPushButton, "start_collection")
        assert start_btn is not None
        
        # 模拟点击
        with qtbot.waitSignal(page.collection_started, timeout=1000):
            qtbot.mouseClick(start_btn, Qt.MouseButton.LeftButton)
```

### 9.4 集成测试示例

```python
"""
浏览器管理器和数据提取器集成测试
"""

import pytest
from src.automation.browser_manager import BrowserManager
from src.automation.product_extractor import ProductExtractor
from src.core.config import Settings

@pytest.mark.asyncio
class TestBrowserIntegration:
    @pytest.fixture
    async def browser_manager(self):
        """创建浏览器管理器"""
        settings = Settings()
        manager = BrowserManager(settings)
        await manager.initialize()
        yield manager
        # 清理
        await manager.cleanup()
    
    async def test_extract_product(self, browser_manager):
        """测试商品提取"""
        # 创建浏览器实例
        instance = await browser_manager.create_instance("test")
        
        # 提取商品信息
        extractor = ProductExtractor(browser_manager)
        product = await extractor.extract_product_info(
            instance.page,
            "https://item.jd.com/100012043978.html"
        )
        
        assert product is not None
        assert "title" in product
        assert "price" in product
```

---

## 10. 部署和打包

### 10.1 使用 PyInstaller 打包

#### 10.1.1 创建 spec 文件

```python
# jdflows.spec

# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    ['main.py'],
    pathex=[],
    binaries=[],
    datas=[
        ('config', 'config'),
        ('resources', 'resources'),
        ('src/gui/shared_styles.qss', 'src/gui'),
    ],
    hiddenimports=[
        'playwright',
        'qasync',
        'loguru',
        'pydantic',
    ],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='JDFlows',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,  # 不显示控制台窗口
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='resources/icons/app_icon.ico',  # 应用图标
)
```

#### 10.1.2 执行打包

```bash
# 使用 spec 文件打包
pyinstaller jdflows.spec

# 或直接命令行打包（简单模式）
pyinstaller --onefile --windowed \
    --icon=resources/icons/app_icon.ico \
    --add-data "config:config" \
    --add-data "resources:resources" \
    --name JDFlows \
    main.py
```

### 10.2 使用 cx_Freeze 打包

```python
# setup.py

from cx_Freeze import setup, Executable
import sys

build_exe_options = {
    "packages": ["PyQt6", "playwright", "sqlalchemy", "pydantic"],
    "include_files": [
        ("config", "config"),
        ("resources", "resources"),
        ("src/gui/shared_styles.qss", "src/gui/shared_styles.qss"),
    ],
    "excludes": ["tkinter", "unittest"],
}

base = None
if sys.platform == "win32":
    base = "Win32GUI"  # 不显示控制台

setup(
    name="JDFlows",
    version="0.1.0",
    description="京东商品采集和自动化桌面应用",
    options={"build_exe": build_exe_options},
    executables=[
        Executable(
            "main.py",
            base=base,
            icon="resources/icons/app_icon.ico",
            target_name="JDFlows.exe",
        )
    ],
)
```

```bash
# 执行打包
python setup.py build
```

### 10.3 发布清单

打包后需要包含的文件：

```
JDFlows-Release/
├── JDFlows.exe           # 主程序
├── config/               # 配置文件目录
│   ├── app.json
│   ├── system.json
│   └── user.json
├── resources/            # 资源文件
│   ├── icons/
│   └── images/
├── data/                 # 数据目录（首次运行创建）
│   └── jdflows.db
├── logs/                 # 日志目录（首次运行创建）
├── README.txt            # 使用说明
└── LICENSE.txt           # 许可证
```

---

## 11. 开发最佳实践

### 11.1 代码风格

#### 11.1.1 遵循 PEP 8 和 Black

```bash
# 格式化代码
black src/ tests/

# 检查代码质量
flake8 src/ tests/

# 类型检查
mypy src/
```

#### 11.1.2 类型注解

```python
# 好的实践 ✅
def calculate_total(items: List[Dict[str, Any]]) -> float:
    total: float = 0.0
    for item in items:
        total += float(item.get("price", 0))
    return total

# 避免的做法 ❌
def calculate_total(items):
    total = 0
    for item in items:
        total += item["price"]
    return total
```

### 11.2 错误处理

```python
# 好的实践 ✅
async def load_product(sku_id: str) -> Optional[Product]:
    try:
        product = await repository.get_by_sku(sku_id)
        if not product:
            logger.warning(f"商品不存在: {sku_id}")
            return None
        return product
    except DatabaseError as e:
        logger.error(f"数据库错误: {e}")
        raise
    except Exception as e:
        logger.error(f"未知错误: {e}")
        raise ApplicationError("加载商品失败") from e

# 避免的做法 ❌
async def load_product(sku_id):
    try:
        return await repository.get_by_sku(sku_id)
    except:
        return None
```

### 11.3 日志记录

```python
# 好的实践 ✅
logger.info(f"开始采集商品, 关键词: {keyword}")
logger.debug(f"浏览器配置: {browser_config}")
logger.warning(f"商品库存不足: {sku_id}")
logger.error(f"采集失败: {error_message}", exc_info=True)

# 避免的做法 ❌
print("开始采集")
logger.info(error)  # 不应该用 info 记录错误
```

### 11.4 异步编程

```python
# 好的实践 ✅
async def process_products(products: List[str]):
    tasks = [extract_product(sku) for sku in products]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return results

# 避免的做法 ❌
async def process_products(products):
    results = []
    for sku in products:
        result = await extract_product(sku)  # 串行执行，效率低
        results.append(result)
    return results
```

---

## 12. 常见问题

### 12.1 Playwright 安装问题

**问题**: `playwright install` 失败

**解决方案**:
```bash
# 设置国内镜像
export PLAYWRIGHT_DOWNLOAD_HOST=https://npmmirror.com/mirrors/playwright/

# 重新安装
playwright install chromium
```

### 12.2 PyQt6 导入错误

**问题**: `ImportError: DLL load failed while importing QtCore`

**解决方案**:
```bash
# 重新安装 PyQt6
pip uninstall PyQt6 PyQt6-Qt6
pip install PyQt6
```

### 12.3 asyncio 和 qasync 集成问题

**问题**: 异步任务不执行

**解决方案**:
```python
# 确保正确设置事件循环
event_loop = qasync.QEventLoop(qt_app)
asyncio.set_event_loop(event_loop)

# 运行异步任务
event_loop.run_until_complete(async_function())
```

### 12.4 数据库锁定问题

**问题**: `database is locked`

**解决方案**:
```python
# 设置超时时间
engine = create_engine(
    "sqlite:///data/jdflows.db",
    connect_args={"timeout": 15}
)

# 或使用 WAL 模式
engine = create_engine(
    "sqlite:///data/jdflows.db?mode=wal",
)
```

---

## 附录

### A. 开发环境检查清单

- [ ] Python 3.11+ 已安装
- [ ] Poetry 或 pip 已安装
- [ ] Playwright 浏览器已安装
- [ ] 依赖包全部安装成功
- [ ] 代码格式化工具已配置
- [ ] Git 钩子已设置
- [ ] IDE/编辑器已配置类型检查

### B. 常用命令速查

```bash
# 运行应用
python main.py

# 运行测试
pytest
pytest --cov=src --cov-report=html

# 代码质量
black src/ tests/
flake8 src/ tests/
mypy src/

# 打包
pyinstaller jdflows.spec
```

### C. 参考资源

- [PyQt6 官方文档](https://www.riverbankcomputing.com/static/Docs/PyQt6/)
- [Playwright Python 文档](https://playwright.dev/python/)
- [SQLAlchemy 文档](https://docs.sqlalchemy.org/)
- [Pydantic 文档](https://docs.pydantic.dev/)
- [qasync GitHub](https://github.com/CabbageDevelopment/qasync)

---

## 结语

本指南提供了从0开始开发 JDFlows 项目的完整路径。遵循这些指导原则和最佳实践，你可以构建一个稳定、可维护、高性能的桌面应用程序。

如有任何问题或建议，欢迎提交 Issue 或 Pull Request！

**祝开发顺利！** 🚀
